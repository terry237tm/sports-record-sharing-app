---
name: 跨平台适配
status: open
created: 2025-09-09T09:22:00Z
updated: 2025-09-10T06:15:48Z
github: https://github.com/terry237tm/sports-record-sharing-app/issues/25
depends_on: [021, 022]
parallel: true
conflicts_with: []
---

# 跨平台适配

## Description
实现微信小程序和H5双平台的完整适配，确保应用在不同平台上具有一致的用户体验和功能表现。通过条件编译、平台特定组件封装、API适配层等技术手段，解决平台差异性问题，提供统一的开发接口和用户体验。

## Acceptance Criteria
- [ ] 条件编译配置完成，支持平台特定代码编译
- [ ] 平台检测工具实现，运行时识别当前平台
- [ ] API差异适配层，统一不同平台的API调用
- [ ] 组件差异封装，平台特定UI组件适配
- [ ] 样式差异处理，不同平台的样式兼容
- [ ] 权限系统适配，微信授权和H5权限处理
- [ ] 分享功能适配，微信分享和H5分享机制
- [ ] 支付功能适配，微信支付和H5支付方案
- [ ] 地图服务适配，腾讯地图和H5地图集成
- [ ] 文件系统适配，不同平台的文件操作
- [ ] 网络请求适配，处理平台网络差异
- [ ] 存储机制适配，本地存储方案统一

## Technical Details
### 平台适配管理器
```typescript
// 平台类型枚举
export enum Platform {
  WEAPP = 'weapp',
  H5 = 'h5',
  RN = 'rn',
  SWAN = 'swan',
  ALIPAY = 'alipay',
  TT = 'tt',
  QQ = 'qq'
}

// 平台信息接口
interface PlatformInfo {
  type: Platform;
  version: string;
  system: string;
  platform: string;
  SDKVersion: string;
  brand: string;
  model: string;
}

// 平台适配管理器
class PlatformAdapter {
  private currentPlatform: Platform;
  private platformInfo: PlatformInfo;
  private adapters: Map<Platform, PlatformSpecificAdapter> = new Map();

  constructor() {
    this.currentPlatform = this.detectPlatform();
    this.platformInfo = this.getPlatformInfo();
    this.initializeAdapters();
  }

  // 检测当前平台
  private detectPlatform(): Platform {
    // Taro内置平台检测
    if (process.env.TARO_ENV === 'weapp') {
      return Platform.WEAPP;
    } else if (process.env.TARO_ENV === 'h5') {
      return Platform.H5;
    }
    
    // 运行时平台检测
    try {
      if (typeof wx !== 'undefined' && wx.getSystemInfoSync) {
        return Platform.WEAPP;
      }
    } catch (e) {
      // 不是微信小程序环境
    }
    
    return Platform.H5;
  }

  // 获取平台信息
  private getPlatformInfo(): PlatformInfo {
    const info: PlatformInfo = {
      type: this.currentPlatform,
      version: '',
      system: '',
      platform: '',
      SDKVersion: '',
      brand: '',
      model: ''
    };

    if (this.currentPlatform === Platform.WEAPP) {
      try {
        const systemInfo = wx.getSystemInfoSync();
        info.version = systemInfo.version;
        info.system = systemInfo.system;
        info.platform = systemInfo.platform;
        info.SDKVersion = systemInfo.SDKVersion;
        info.brand = systemInfo.brand;
        info.model = systemInfo.model;
      } catch (error) {
        console.error('获取微信小程序系统信息失败:', error);
      }
    } else if (this.currentPlatform === Platform.H5) {
      const userAgent = navigator.userAgent;
      info.version = navigator.appVersion;
      info.system = this.parseOSSystem(userAgent);
      info.platform = 'web';
      info.SDKVersion = '';
      info.brand = this.parseBrowserBrand(userAgent);
      info.model = '';
    }

    return info;
  }

  // 解析操作系统
  private parseOSSystem(userAgent: string): string {
    const osPatterns = {
      'iOS': /iPhone|iPad|iPod/,
      'Android': /Android/,
      'Windows': /Windows/,
      'MacOS': /Macintosh/,
      'Linux': /Linux/
    };

    for (const [os, pattern] of Object.entries(osPatterns)) {
      if (pattern.test(userAgent)) {
        return os;
      }
    }
    return 'Unknown';
  }

  // 解析浏览器品牌
  private parseBrowserBrand(userAgent: string): string {
    const browserPatterns = {
      'WeChat': /MicroMessenger/,
      'Chrome': /Chrome/,
      'Safari': /Safari/,
      'Firefox': /Firefox/,
      'Edge': /Edge/,
      'Opera': /Opera/
    };

    for (const [browser, pattern] of Object.entries(browserPatterns)) {
      if (pattern.test(userAgent)) {
        return browser;
      }
    }
    return 'Unknown';
  }

  // 初始化平台适配器
  private initializeAdapters(): void {
    this.adapters.set(Platform.WEAPP, new WeappAdapter());
    this.adapters.set(Platform.H5, new H5Adapter());
  }

  // 获取当前平台
  getCurrentPlatform(): Platform {
    return this.currentPlatform;
  }

  // 获取平台信息
  getPlatformInfo(): PlatformInfo {
    return this.platformInfo;
  }

  // 获取平台特定适配器
  getAdapter(): PlatformSpecificAdapter {
    const adapter = this.adapters.get(this.currentPlatform);
    if (!adapter) {
      throw new Error(`未找到平台适配器: ${this.currentPlatform}`);
    }
    return adapter;
  }

  // 条件执行平台特定代码
  platformSpecific<T>(
    weappImpl: () => T,
    h5Impl: () => T,
    defaultImpl?: () => T
  ): T {
    switch (this.currentPlatform) {
      case Platform.WEAPP:
        return weappImpl();
      case Platform.H5:
        return h5Impl();
      default:
        if (defaultImpl) {
          return defaultImpl();
        }
        throw new Error(`不支持的平台: ${this.currentPlatform}`);
    }
  }

  // 检查是否为微信小程序
  isWeapp(): boolean {
    return this.currentPlatform === Platform.WEAPP;
  }

  // 检查是否为H5
  isH5(): boolean {
    return this.currentPlatform === Platform.H5;
  }

  // 获取平台特定配置
  getPlatformConfig<T>(config: PlatformConfig<T>): T {
    return this.platformSpecific(
      () => config.weapp,
      () => config.h5,
      () => config.default
    );
  }
}

// 平台特定适配器接口
interface PlatformSpecificAdapter {
  // 用户授权
  requestAuth(scope: string): Promise<boolean>;
  
  // 获取用户信息
  getUserInfo(): Promise<UserInfo>;
  
  // 分享功能
  share(options: ShareOptions): Promise<void>;
  
  // 支付功能
  requestPayment(params: PaymentParams): Promise<void>;
  
  // 位置服务
  getLocation(): Promise<LocationData>;
  
  // 文件上传
  uploadFile(options: UploadOptions): Promise<UploadResult>;
  
  // 本地存储
  setStorage(key: string, data: any): Promise<void>;
  getStorage(key: string): Promise<any>;
  removeStorage(key: string): Promise<void>;
  
  // 网络请求
  request(options: RequestOptions): Promise<any>;
  
  // 图片处理
  chooseImage(options?: ChooseImageOptions): Promise<ChooseImageResult>;
  previewImage(options: PreviewImageOptions): Promise<void>;
  
  // 界面交互
  showToast(options: ToastOptions): void;
  showModal(options: ModalOptions): Promise<ModalResult>;
  showLoading(options: LoadingOptions): void;
  hideLoading(): void;
  
  // 导航
  navigateTo(url: string): Promise<void>;
  navigateBack(delta?: number): Promise<void>;
  redirectTo(url: string): Promise<void>;
  switchTab(url: string): Promise<void>;
  reLaunch(url: string): Promise<void>;
}

// 微信小程序适配器
class WeappAdapter implements PlatformSpecificAdapter {
  async requestAuth(scope: string): Promise<boolean> {
    return new Promise((resolve) => {
      wx.authorize({
        scope,
        success: () => resolve(true),
        fail: () => resolve(false)
      });
    });
  }

  async getUserInfo(): Promise<UserInfo> {
    return new Promise((resolve, reject) => {
      wx.getUserProfile({
        desc: '用于完善用户资料',
        success: (res) => {
          resolve({
            nickName: res.userInfo.nickName,
            avatarUrl: res.userInfo.avatarUrl,
            gender: res.userInfo.gender,
            city: res.userInfo.city,
            province: res.userInfo.province,
            country: res.userInfo.country
          });
        },
        fail: reject
      });
    });
  }

  async share(options: ShareOptions): Promise<void> {
    // 微信小程序分享需要在页面中定义onShareAppMessage
    if (typeof Page !== 'undefined') {
      Page({
        onShareAppMessage: () => ({
          title: options.title,
          path: options.path,
          imageUrl: options.imageUrl
        })
      });
    }
  }

  async requestPayment(params: PaymentParams): Promise<void> {
    return new Promise((resolve, reject) => {
      wx.requestPayment({
        ...params,
        success: resolve,
        fail: reject
      });
    });
  }

  async getLocation(): Promise<LocationData> {
    return new Promise((resolve, reject) => {
      wx.getLocation({
        type: 'gcj02',
        success: (res) => {
          resolve({
            latitude: res.latitude,
            longitude: res.longitude,
            speed: res.speed,
            accuracy: res.accuracy
          });
        },
        fail: reject
      });
    });
  }

  async uploadFile(options: UploadOptions): Promise<UploadResult> {
    return new Promise((resolve, reject) => {
      wx.uploadFile({
        url: options.url,
        filePath: options.filePath,
        name: options.name,
        formData: options.formData,
        success: (res) => {
          resolve({
            statusCode: res.statusCode,
            data: res.data
          });
        },
        fail: reject
      });
    });
  }

  async setStorage(key: string, data: any): Promise<void> {
    wx.setStorageSync(key, data);
  }

  async getStorage(key: string): Promise<any> {
    return wx.getStorageSync(key);
  }

  async removeStorage(key: string): Promise<void> {
    wx.removeStorageSync(key);
  }

  async request(options: RequestOptions): Promise<any> {
    return new Promise((resolve, reject) => {
      wx.request({
        url: options.url,
        method: options.method || 'GET',
        data: options.data,
        header: options.header,
        timeout: options.timeout || 30000,
        success: (res) => {
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve(res.data);
          } else {
            reject(new Error(`Request failed with status ${res.statusCode}`));
          }
        },
        fail: reject
      });
    });
  }

  async chooseImage(options?: ChooseImageOptions): Promise<ChooseImageResult> {
    return new Promise((resolve, reject) => {
      wx.chooseImage({
        count: options?.count || 9,
        sizeType: options?.sizeType || ['original', 'compressed'],
        sourceType: options?.sourceType || ['album', 'camera'],
        success: (res) => {
          resolve({
            tempFilePaths: res.tempFilePaths,
            tempFiles: res.tempFiles.map(file => ({
              path: file.path,
              size: file.size
            }))
          });
        },
        fail: reject
      });
    });
  }

  async previewImage(options: PreviewImageOptions): Promise<void> {
    return new Promise((resolve) => {
      wx.previewImage({
        urls: options.urls,
        current: options.current,
        success: resolve
      });
    });
  }

  showToast(options: ToastOptions): void {
    wx.showToast({
      title: options.title,
      icon: options.icon || 'none',
      duration: options.duration || 2000,
      mask: options.mask || false
    });
  }

  async showModal(options: ModalOptions): Promise<ModalResult> {
    return new Promise((resolve) => {
      wx.showModal({
        title: options.title,
        content: options.content,
        showCancel: options.showCancel !== false,
        cancelText: options.cancelText || '取消',
        confirmText: options.confirmText || '确定',
        success: (res) => {
          resolve({
            confirm: res.confirm,
            cancel: res.cancel
          });
        }
      });
    });
  }

  showLoading(options: LoadingOptions): void {
    wx.showLoading({
      title: options.title || '加载中...',
      mask: options.mask !== false
    });
  }

  hideLoading(): void {
    wx.hideLoading();
  }

  async navigateTo(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      wx.navigateTo({
        url,
        success: resolve,
        fail: reject
      });
    });
  }

  async navigateBack(delta?: number): Promise<void> {
    return new Promise((resolve) => {
      wx.navigateBack({
        delta: delta || 1,
        success: resolve
      });
    });
  }

  async redirectTo(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      wx.redirectTo({
        url,
        success: resolve,
        fail: reject
      });
    });
  }

  async switchTab(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      wx.switchTab({
        url,
        success: resolve,
        fail: reject
      });
    });
  }

  async reLaunch(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      wx.reLaunch({
        url,
        success: resolve,
        fail: reject
      });
    });
  }
}
```

## Dependencies
- 依赖任务021（页面集成与导航）提供页面结构
- 依赖任务022（性能优化与调试）提供性能基础

## Effort Estimate
- **Size**: L (大)
- **Estimated Hours**: 20-24 小时

## Definition of Done
- [ ] 条件编译配置完整实现，支持所有平台的特定代码编译
- [ ] 平台检测工具准确识别微信小程序、H5等平台环境
- [ ] API差异适配层统一封装，提供一致的API调用接口
- [ ] 组件差异封装完成，平台特定UI组件正确适配
- [ ] 样式差异处理实现，不同平台的样式兼容和响应式适配
- [ ] 权限系统适配完成，微信授权流程和H5权限处理统一
- [ ] 分享功能适配实现，支持微信分享和H5社交分享
- [ ] 支付功能适配完成，微信支付和H5支付方案集成
- [ ] 地图服务适配实现，腾讯地图和H5地图服务统一
- [ ] 文件系统适配完成，不同平台的文件上传和管理
- [ ] 网络请求适配实现，处理平台网络请求差异
- [ ] 存储机制适配完成，本地存储方案统一封装
- [ ] 跨平台测试通过，各平台功能一致性和兼容性验证
- [ ] 平台特定功能降级处理，确保核心功能可用性
- [ ] 跨平台文档编写，包含适配指南和最佳实践

## Performance Requirements
- 平台检测时间：< 10ms（运行时平台识别）
- 适配器调用延迟：< 50ms（API适配开销）
- 条件编译效率：< 100ms（编译时平台选择）
- 跨平台兼容性：> 95%（功能一致性覆盖率）
- 平台特定功能可用性：> 90%（平台能力利用率）

## Security and Privacy
- 平台权限正确适配，确保权限申请合规
- 用户隐私保护，不同平台的隐私策略遵循
- 数据安全传输，跨平台数据一致性保证
- 平台安全机制，利用各平台安全能力

## Monitoring and Maintenance
- 跨平台兼容性监控
- 平台功能使用统计
- 适配错误率追踪
- 用户体验一致性分析
- 平台能力变更跟踪

## Future Enhancements
- 新平台支持
- 平台能力自动检测
- 智能适配推荐
- 跨平台性能优化
- 统一开发体验

## Analytics Best Practices
- 建立跨平台使用分析
- 平台功能适配效果评估
- 用户体验一致性监控
- 平台能力利用率分析
- 持续适配改进

## Compliance and Governance
- 跨平台合规性检查
- 平台政策遵循验证
- 数据跨平台合规
- 定期适配审查
- 治理流程建立

## Documentation and Training
- 编写跨平台开发手册
- 提供平台适配指南
- 制作适配演示视频
- 建立最佳实践库
- 开展团队培训

## Performance Optimization
- 适配器性能优化
- 条件编译效率提升
- 平台检测缓存
- 跨平台代码优化
- 运行时性能监控

## Accessibility
- 跨平台无障碍支持
- 平台辅助功能适配
- 无障碍体验一致性
- 辅助技术兼容性
- 用户体验全面性

## Internationalization
- 跨平台多语言支持
- 平台本地化差异处理
- 国际化适配一致性
- 文化习惯平台适配
- 全球化用户体验

## Testing Strategy
- 跨平台功能测试
- 兼容性测试验证
- 平台特定功能测试
- 用户体验一致性测试
- 性能兼容性测试

## Deployment Considerations
- 跨平台部署策略
- 平台特定配置管理
- 条件编译部署
- 多平台发布流程
- 版本兼容性管理

## Risk Assessment
- 平台差异风险
- 适配兼容性风险
- 功能降级风险
- 用户体验差异风险
- 平台政策变更风险

## Success Metrics
- 跨平台一致性指标
- 功能适配成功率
- 用户体验满意度
- 开发效率提升
- 维护成本降低

## Maintenance Plan
- 跨平台适配维护
- 平台能力跟踪
- 兼容性持续验证
- 用户反馈处理
- 适配策略更新

## Technical Debt Management
- 跨平台代码重构
- 适配器架构优化
- 平台差异抽象
- 技术栈升级路径
- 维护成本控制

## Knowledge Transfer
- 跨平台开发经验
- 平台差异知识
- 适配最佳实践
- 问题解决方案
- 技术决策记录

## Continuous Improvement
- 跨平台体验持续优化
- 平台能力深度集成
- 开发效率提升
- 用户体验统一
- 技术创新应用

## Team Collaboration
- 跨平台开发协作
- 平台问题共享
- 适配经验交流
- 技术决策协作
- 最佳实践推广

## Stakeholder Communication
- 跨平台适配成果汇报
- 平台兼容性展示
- 用户体验一致性验证
- 技术价值体现
- 商业价值量化

## Quality Assurance
- 跨平台代码质量
- 适配功能完整性
- 兼容性测试验证
- 用户体验评估
- 平台合规性检查

## Innovation Opportunities
- 智能跨平台适配
- 自动平台检测
- 统一开发框架
- 跨平台AI优化
- 新兴平台支持

## Scalability Considerations
- 跨平台架构扩展性
- 新平台快速支持
- 平台能力动态加载
- 大规模适配管理
- 全球化平台支持

## Business Value
- 开发成本节约
- 市场覆盖扩大
- 用户体验一致性
- 维护效率提升
- 技术投资保护

## Competitive Analysis
- 跨平台技术优势
- 平台覆盖竞争力
- 开发效率对比
- 用户体验优势
- 技术领先性

## Roadmap Alignment
- 跨平台技术规划
- 平台生态发展
- 市场策略匹配
- 技术投资方向
- 长期价值实现

## Resource Requirements
- 跨平台开发专家
- 多平台测试资源
- 平台适配工具
- 兼容性测试环境
- 持续集成支持

## Timeline Management
- 跨平台适配周期
- 平台发布计划
- 兼容性验证时间
- 平台更新响应
- 里程碑协调

## Communication Plan
- 跨平台团队沟通
- 平台问题协调
- 技术决策沟通
- 用户反馈处理
- 外部合作沟通

## Risk Mitigation
- 平台差异风险应对
- 兼容性风险控制
- 政策变更风险
- 技术风险预案
- 业务连续性保障

## Success Factors
- 跨平台一致性
- 功能完整性
- 用户体验统一
- 开发效率提升
- 维护成本优化

## Lessons Learned
- 跨平台开发教训
- 平台差异处理经验
- 适配策略优化
- 团队协作改进
- 技术决策反思

## Future Considerations
- 新兴平台趋势
- 跨平台技术发展
- 用户需求变化
- 平台生态演进
- 技术战略调整
