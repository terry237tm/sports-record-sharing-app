---
name: 表单验证与错误处理
status: open
created: 2025-09-09T09:19:22Z
updated: 2025-09-10T06:15:48Z
github: https://github.com/terry237tm/sports-record-sharing-app/issues/11
depends_on: [001, 002, 003, 004, 005]
parallel: true
conflicts_with: []
---

# 表单验证与错误处理

## Description
建立完整的表单验证体系和错误处理机制，确保用户输入的数据合法有效。提供实时的验证反馈和友好的错误提示，提升用户体验并保证数据质量。

## Acceptance Criteria
- [ ] JSON Schema验证规则定义，覆盖所有表单字段
- [ ] 实时验证功能，用户输入时即时反馈
- [ ] 异步验证支持，如用户名唯一性检查
- [ ] 错误信息本地化，支持中文错误提示
- [ ] 表单提交前整体验证，阻止无效数据提交
- [ ] 错误信息可视化展示，字段级错误高亮显示
- [ ] 验证状态管理，支持验证通过/失败/待验证状态
- [ ] 自定义验证规则支持，满足特殊业务需求
- [ ] 错误恢复机制，用户修正后自动清除错误状态
- [ ] 验证性能优化，避免频繁验证影响用户体验

## Technical Details
### 验证框架设计
```typescript
// 验证规则接口
interface ValidationRule {
  required?: boolean;
  type?: 'string' | 'number' | 'boolean' | 'array' | 'object';
  min?: number;
  max?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  enum?: any[];
  custom?: (value: any, formData: any) => Promise<ValidationResult>;
  message?: string | ((value: any) => string);
}

// 验证结果
interface ValidationResult {
  valid: boolean;
  errors?: ValidationError[];
}

interface ValidationError {
  field: string;
  message: string;
  code: string;
  value?: any;
}
```

### JSON Schema验证规则
```typescript
// 运动记录表单验证规则
const sportRecordSchema = {
  type: 'object',
  properties: {
    sportType: {
      type: 'string',
      required: true,
      enum: Object.values(SportType),
      message: '请选择运动类型'
    },
    duration: {
      type: 'number',
      required: true,
      min: 1,
      max: 1440,
      message: '运动时长必须在1-1440分钟之间'
    },
    distance: {
      type: 'number',
      min: 0.1,
      max: 200,
      message: '运动距离必须在0.1-200公里之间'
    },
    calories: {
      type: 'number',
      required: true,
      min: 10,
      max: 5000,
      message: '消耗卡路里必须在10-5000之间'
    },
    description: {
      type: 'string',
      maxLength: 500,
      message: '运动描述不能超过500字符'
    },
    images: {
      type: 'array',
      maxItems: 9,
      message: '最多只能上传9张图片'
    }
  }
};
```

### 验证器实现
```typescript
class FormValidator {
  private rules: Map<string, ValidationRule[]> = new Map();
  private errors: Map<string, ValidationError[]> = new Map();
  
  // 添加验证规则
  addRule(field: string, rule: ValidationRule): void {
    if (!this.rules.has(field)) {
      this.rules.set(field, []);
    }
    this.rules.get(field)!.push(rule);
  }
  
  // 验证单个字段
  async validateField(field: string, value: any, formData: any): Promise<ValidationResult> {
    const fieldRules = this.rules.get(field) || [];
    const errors: ValidationError[] = [];
    
    for (const rule of fieldRules) {
      const result = await this.validateRule(value, rule, formData, field);
      if (!result.valid && result.errors) {
        errors.push(...result.errors);
      }
    }
    
    if (errors.length > 0) {
      this.errors.set(field, errors);
      return { valid: false, errors };
    } else {
      this.errors.delete(field);
      return { valid: true };
    }
  }
  
  // 验证整个表单
  async validateForm(formData: any): Promise<ValidationResult> {
    const allErrors: ValidationError[] = [];
    
    for (const [field, rules] of this.rules) {
      const value = formData[field];
      const result = await this.validateField(field, value, formData);
      
      if (!result.valid && result.errors) {
        allErrors.push(...result.errors);
      }
    }
    
    return {
      valid: allErrors.length === 0,
      errors: allErrors.length > 0 ? allErrors : undefined
    };
  }
  
  // 验证单个规则
  private async validateRule(value: any, rule: ValidationRule, formData: any, field: string): Promise<ValidationResult> {
    // 必填验证
    if (rule.required && (value === undefined || value === null || value === '')) {
      return {
        valid: false,
        errors: [{ field, message: rule.message || `${field}不能为空`, code: 'required' }]
      };
    }
    
    // 类型验证
    if (value !== undefined && rule.type && typeof value !== rule.type) {
      return {
        valid: false,
        errors: [{ field, message: rule.message || `${field}类型错误`, code: 'type' }]
      };
    }
    
    // 自定义验证
    if (rule.custom) {
      return await rule.custom(value, formData);
    }
    
    return { valid: true };
  }
}
```

### 组件集成
```typescript
// 表单字段组件
interface FormFieldProps {
  name: string;
  value: any;
  onChange: (value: any) => void;
  validator: FormValidator;
  children: React.ReactNode;
}

const FormField: React.FC<FormFieldProps> = ({ name, value, onChange, validator, children }) => {
  const [errors, setErrors] = useState<ValidationError[]>([]);
  const [validating, setValidating] = useState(false);
  
  const handleChange = async (newValue: any) => {
    onChange(newValue);
    
    // 实时验证
    setValidating(true);
    const result = await validator.validateField(name, newValue, formData);
    setValidating(false);
    
    if (result.errors) {
      setErrors(result.errors);
    } else {
      setErrors([]);
    }
  };
  
  return (
    <View className="form-field">
      {React.cloneElement(children as React.ReactElement, {
        value,
        onChange: handleChange,
        className: errors.length > 0 ? 'error' : ''
      })}
      {errors.length > 0 && (
        <View className="field-errors">
          {errors.map((error, index) => (
            <Text key={index} className="error-message">
              {error.message}
            </Text>
          ))}
        </View>
      )}
    </View>
  );
};
```

### 错误信息国际化
```typescript
const validationMessages = {
  zh: {
    required: '{field}不能为空',
    type: '{field}类型错误',
    min: '{field}不能小于{min}',
    max: '{field}不能大于{max}',
    minLength: '{field}长度不能少于{minLength}个字符',
    maxLength: '{field}长度不能超过{maxLength}个字符',
    pattern: '{field}格式不正确',
    enum: '{field}必须是以下值之一：{enum}'
  }
};
```

### 性能优化策略
- **防抖验证**：避免频繁输入触发过多验证
- **异步验证队列**：管理多个异步验证任务
- **验证缓存**：相同数据不重复验证
- **渐进式验证**：先验证简单规则，再验证复杂规则

### 错误恢复机制
- **自动修复**：某些错误可以自动修正
- **手动修复**：提供清晰的修复指导
- **错误状态清除**：数据修正后自动清除错误
- **验证历史**：记录验证历史便于调试

## Dependencies
- 依赖任务001-005完成（基础架构和工具函数）
- 依赖任务006-008的表单字段定义

## Effort Estimate
- **Size**: L (大型)
- **Estimated Hours**: 12-16 小时

## Definition of Done
- [ ] JSON Schema验证规则完整定义，覆盖所有业务场景
- [ ] 实时验证功能稳定，不影响用户输入体验
- [ ] 异步验证机制可靠，正确处理并发验证
- [ ] 错误信息展示友好，用户易于理解和修正
- [ ] 验证性能优化到位，大表单验证响应迅速
- [ ] 自定义验证规则扩展性强，支持复杂业务逻辑
- [ ] 错误恢复机制完善，用户修正后状态正确更新
- [ ] 单元测试覆盖率高，验证逻辑正确性有保障
- [ ] 与UI组件集成良好，提供一致的验证体验
- [ ] 文档完整，包含使用示例和最佳实践
- [ ] 代码审查通过，符合项目质量标准
- [ ] 性能测试通过，验证过程不影响整体性能
