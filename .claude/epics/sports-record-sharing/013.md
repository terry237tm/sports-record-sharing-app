---
name: 图片导出与保存
status: open
created: 2025-09-09T09:19:22Z
updated: 2025-09-09T09:19:22Z
github: placeholder
depends_on: [011, 012]
parallel: true
conflicts_with: []
---

# 图片导出与保存

## Description
实现分享图片的导出和保存功能，支持多种格式、质量参数、尺寸规格的图片导出。集成相册保存、文件系统存储、云存储上传等功能，确保生成的分享图片能够方便地保存和分享。

## Acceptance Criteria
- [ ] 图片导出管理器实现，支持多种导出格式（PNG、JPEG、WebP）
- [ ] 导出质量参数控制，支持自定义压缩率和图片质量
- [ ] 多种尺寸规格支持，适配不同平台的分享要求
- [ ] 微信小程序相册保存功能，获得用户授权后保存到系统相册
- [ ] H5平台文件下载功能，支持浏览器下载和图片保存
- [ ] 云存储上传集成，将生成的图片上传到云存储服务
- [ ] 图片压缩和优化，在保证质量的前提下减小文件大小
- [ ] 批量导出功能，支持一次生成多种规格的图片
- [ ] 导出进度反馈，实时显示导出进度和状态
- [ ] 错误处理和重试机制，确保导出过程的稳定性

## Technical Details
### 图片导出管理器
```typescript
// 图片导出管理器
class ImageExportManager {
  private exportConfig: ExportConfig;
  
  constructor(config: ExportConfig) {
    this.exportConfig = config;
  }
  
  async exportImage(
    canvas: HTMLCanvasElement,
    options: ExportOptions
  ): Promise<ExportResult> {
    try {
      // 设置导出参数
      const exportParams = this.buildExportParams(options);
      
      // 生成不同格式
      const results: ExportResult = {
        formats: {},
        metadata: {},
        timestamp: Date.now()
      };
      
      // 导出PNG格式
      if (options.formats.includes('png')) {
        results.formats.png = await this.exportPNG(canvas, exportParams.png);
      }
      
      // 导出JPEG格式
      if (options.formats.includes('jpeg')) {
        results.formats.jpeg = await this.exportJPEG(canvas, exportParams.jpeg);
      }
      
      // 导出WebP格式
      if (options.formats.includes('webp') && this.supportWebP()) {
        results.formats.webp = await this.exportWebP(canvas, exportParams.webp);
      }
      
      // 生成元数据
      results.metadata = await this.generateMetadata(canvas, results);
      
      return results;
      
    } catch (error) {
      throw new ImageExportError(`图片导出失败: ${error.message}`);
    }
  }
  
  private buildExportParams(options: ExportOptions): FormatExportParams {
    return {
      png: {
        quality: 1.0,
        compression: 'default'
      },
      jpeg: {
        quality: options.quality || 0.9,
        progressive: true,
        optimize: true
      },
      webp: {
        quality: options.quality || 0.85,
        lossless: false,
        effort: 6
      }
    };
  }
}
```

### 微信小程序相册保存
```typescript
// 微信小程序图片保存管理器
class WeappImageSaver {
  private authManager: AuthManager;
  
  constructor(authManager: AuthManager) {
    this.authManager = authManager;
  }
  
  async saveToAlbum(filePath: string): Promise<boolean> {
    try {
      // 检查相册权限
      const hasAuth = await this.checkAlbumAuth();
      if (!hasAuth) {
        const granted = await this.requestAlbumAuth();
        if (!granted) {
          throw new Error('用户拒绝相册权限');
        }
      }
      
      // 保存图片到相册
      return new Promise((resolve, reject) => {
        Taro.saveImageToPhotosAlbum({
          filePath,
          success: () => {
            resolve(true);
          },
          fail: (error) => {
            reject(new Error(`保存失败: ${error.errMsg}`));
          }
        });
      });
      
    } catch (error) {
      console.error('保存到相册失败:', error);
      throw error;
    }
  }
  
  private async checkAlbumAuth(): Promise<boolean> {
    try {
      const setting = await Taro.getSetting();
      const albumAuth = setting.authSetting['scope.writePhotosAlbum'];
      return albumAuth === true;
    } catch (error) {
      return false;
    }
  }
  
  private async requestAlbumAuth(): Promise<boolean> {
    try {
      await Taro.authorize({ scope: 'scope.writePhotosAlbum' });
      return true;
    } catch (error) {
      // 用户拒绝授权，引导用户手动开启
      const modalResult = await Taro.showModal({
        title: '需要相册权限',
        content: '保存图片需要您的相册权限，是否前往设置开启？',
        confirmText: '前往设置',
        cancelText: '取消'
      });
      
      if (modalResult.confirm) {
        await Taro.openSetting();
        return await this.checkAlbumAuth();
      }
      
      return false;
    }
  }
  
  // 临时文件管理
  async createTempFile(dataUrl: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const filePath = `${Taro.env.USER_DATA_PATH}/share_image_${Date.now()}.png`;
      
      // base64转换为临时文件
      const base64Data = dataUrl.replace(/^data:image\/\w+;base64,/, '');
      const buffer = Taro.base64ToArrayBuffer(base64Data);
      
      Taro.getFileSystemManager().writeFile({
        filePath,
        data: buffer,
        encoding: 'binary',
        success: () => resolve(filePath),
        fail: reject
      });
    });
  }
  
  // 清理临时文件
  async cleanupTempFiles(): Promise<void> {
    try {
      const fileManager = Taro.getFileSystemManager();
      const userPath = Taro.env.USER_DATA_PATH;
      
      // 删除分享图片临时文件
      const files = await fileManager.readdir(userPath);
      const tempFiles = files.filter(file => 
        file.startsWith('share_image_') && file.endsWith('.png')
      );
      
      for (const file of tempFiles) {
        await fileManager.unlink(`${userPath}/${file}`);
      }
    } catch (error) {
      console.warn('清理临时文件失败:', error);
    }
  }
}
```

### H5平台文件下载
```typescript
// H5图片下载管理器
class H5ImageDownloader {
  async downloadImage(dataUrl: string, filename: string): Promise<void> {
    try {
      // 创建下载链接
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = filename || `share_image_${Date.now()}.png`;
      link.style.display = 'none';
      
      // 添加到DOM并触发下载
      document.body.appendChild(link);
      link.click();
      
      // 清理
      setTimeout(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
      }, 100);
      
    } catch (error) {
      // 降级方案：使用Blob下载
      await this.downloadWithBlob(dataUrl, filename);
    }
  }
  
  private async downloadWithBlob(dataUrl: string, filename: string): Promise<void> {
    try {
      const response = await fetch(dataUrl);
      const blob = await response.blob();
      const blobUrl = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = blobUrl;
      link.download = filename;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      
      setTimeout(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(blobUrl);
      }, 100);
      
    } catch (error) {
      throw new Error(`文件下载失败: ${error.message}`);
    }
  }
  
  // 批量下载
  async downloadMultiple(images: Array<{ dataUrl: string; filename: string }>): Promise<void> {
    for (let i = 0; i < images.length; i++) {
      const image = images[i];
      
      // 延迟下载避免浏览器限制
      await new Promise(resolve => setTimeout(resolve, i * 500));
      
      try {
        await this.downloadImage(image.dataUrl, image.filename);
      } catch (error) {
        console.error(`下载失败 ${image.filename}:`, error);
      }
    }
  }
}
```

### 云存储上传集成
```typescript
// 云存储上传管理器
class CloudStorageUploader {
  private cloudBase: CloudBase;
  
  constructor(cloudBase: CloudBase) {
    this.cloudBase = cloudBase;
  }
  
  async uploadImage(
    dataUrl: string,
    options: UploadOptions
  ): Promise<UploadResult> {
    try {
      // 数据URL转换为文件
      const file = this.dataUrlToFile(dataUrl, options.filename);
      
      // 生成文件路径
      const filePath = this.generateFilePath(options);
      
      // 上传到云存储
      const uploadResult = await this.cloudBase.uploadFile({
        cloudPath: filePath,
        filePath: file,
        config: {
          header: {
            'Content-Type': 'image/png'
          }
        }
      });
      
      // 获取文件信息
      const fileInfo = await this.cloudBase.getFileInfo({
        fileList: [uploadResult.fileID]
      });
      
      return {
        fileId: uploadResult.fileID,
        filePath: filePath,
        fileUrl: uploadResult.fileID,
        size: fileInfo.fileList[0].size,
        uploadTime: new Date(),
        status: 'success'
      };
      
    } catch (error) {
      throw new CloudUploadError(`上传失败: ${error.message}`);
    }
  }
  
  private dataUrlToFile(dataUrl: string, filename: string): File {
    const arr = dataUrl.split(',');
    const mime = arr[0].match(/:(.*?);/)![1];
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    
    return new File([u8arr], filename, { type: mime });
  }
  
  private generateFilePath(options: UploadOptions): string {
    const timestamp = Date.now();
    const date = new Date();
    const dateStr = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
    
    return `share-images/${dateStr}/${options.userId}_${timestamp}_${options.filename}`;
  }
  
  // 批量上传
  async uploadMultiple(
    images: Array<{ dataUrl: string; options: UploadOptions }>
  ): Promise<BatchUploadResult> {
    const results: BatchUploadResult = {
      successful: [],
      failed: [],
      total: images.length
    };
    
    // 并发上传控制
    const concurrency = 3;
    const chunks = this.chunkArray(images, concurrency);
    
    for (const chunk of chunks) {
      const uploadPromises = chunk.map(async ({ dataUrl, options }) => {
        try {
          const result = await this.uploadImage(dataUrl, options);
          results.successful.push(result);
          return result;
        } catch (error) {
          const failedResult: FailedUpload = {
            options,
            error: error.message,
            timestamp: new Date()
          };
          results.failed.push(failedResult);
          return null;
        }
      });
      
      await Promise.all(uploadPromises);
    }
    
    return results;
  }
  
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}
```

### 图片压缩和优化
```typescript
// 图片压缩优化器
class ImageOptimizer {
  async optimizeImage(
    canvas: HTMLCanvasElement,
    options: OptimizeOptions
  ): Promise<string> {
    let processedCanvas = canvas;
    
    // 尺寸优化
    if (options.resize) {
      processedCanvas = await this.resizeCanvas(canvas, options.resize);
    }
    
    // 质量压缩
    const quality = options.quality || 0.85;
    const format = options.format || 'jpeg';
    
    // 智能压缩
    if (options.smartCompression) {
      return await this.smartCompress(processedCanvas, format, quality);
    }
    
    // 标准压缩
    return processedCanvas.toDataURL(`image/${format}`, quality);
  }
  
  private async smartCompress(
    canvas: HTMLCanvasElement,
    format: string,
    targetQuality: number
  ): Promise<string> {
    // 分析图片内容复杂度
    const complexity = await this.analyzeImageComplexity(canvas);
    
    // 根据复杂度调整压缩参数
    let quality = targetQuality;
    let compressionLevel = 6;
    
    if (complexity < 0.3) {
      // 简单图片，可以提高压缩率
      quality = Math.max(0.6, targetQuality - 0.2);
      compressionLevel = 9;
    } else if (complexity > 0.7) {
      // 复杂图片，降低压缩率
      quality = Math.min(1.0, targetQuality + 0.1);
      compressionLevel = 3;
    }
    
    return canvas.toDataURL(`image/${format}`, quality);
  }
  
  private async analyzeImageComplexity(canvas: HTMLCanvasElement): Promise<number> {
    const ctx = canvas.getContext('2d')!;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    let totalVariation = 0;
    let sampleCount = 0;
    
    // 采样分析，避免性能问题
    const step = Math.max(1, Math.floor(Math.sqrt(data.length / 4) / 100));
    
    for (let i = 0; i < data.length; i += 4 * step) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // 计算与周围像素的变化
      if (i + 4 * step < data.length) {
        const nextR = data[i + 4 * step];
        const nextG = data[i + 4 * step + 1];
        const nextB = data[i + 4 * step + 2];
        
        const variation = Math.abs(r - nextR) + Math.abs(g - nextG) + Math.abs(b - nextB);
        totalVariation += variation;
        sampleCount++;
      }
    }
    
    const avgVariation = totalVariation / (sampleCount * 3 * 255);
    return Math.min(1.0, avgVariation);
  }
  
  private async resizeCanvas(
    canvas: HTMLCanvasElement,
    resizeOptions: ResizeOptions
  ): Promise<HTMLCanvasElement> {
    const { width, height, maintainAspectRatio = true } = resizeOptions;
    
    let newWidth = width;
    let newHeight = height;
    
    if (maintainAspectRatio) {
      const aspectRatio = canvas.width / canvas.height;
      
      if (width && !height) {
        newHeight = width / aspectRatio;
      } else if (height && !width) {
        newWidth = height * aspectRatio;
      } else if (width && height) {
        // 选择最合适的尺寸
        const widthRatio = width / canvas.width;
        const heightRatio = height / canvas.height;
        const ratio = Math.min(widthRatio, heightRatio);
        
        newWidth = canvas.width * ratio;
        newHeight = canvas.height * ratio;
      }
    }
    
    // 创建新的canvas
    const newCanvas = document.createElement('canvas');
    newCanvas.width = newWidth;
    newCanvas.height = newHeight;
    
    const ctx = newCanvas.getContext('2d')!;
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // 绘制缩放后的图片
    ctx.drawImage(canvas, 0, 0, newWidth, newHeight);
    
    return newCanvas;
  }
}
```

### 导出进度管理
```typescript
// 导出进度管理器
class ExportProgressManager extends EventEmitter {
  private currentProgress: ExportProgress = {
    total: 0,
    completed: 0,
    percentage: 0,
    status: 'idle',
    currentTask: ''
  };
  
  startExport(totalTasks: number): void {
    this.currentProgress = {
      total: totalTasks,
      completed: 0,
      percentage: 0,
      status: 'exporting',
      currentTask: '开始导出...'
    };
    
    this.emit('progress', this.currentProgress);
  }
  
  updateProgress(completed: number, currentTask: string): void {
    this.currentProgress.completed = completed;
    this.currentProgress.percentage = Math.round((completed / this.currentProgress.total) * 100);
    this.currentProgress.currentTask = currentTask;
    
    this.emit('progress', this.currentProgress);
  }
  
  completeExport(): void {
    this.currentProgress.status = 'completed';
    this.currentProgress.percentage = 100;
    this.currentProgress.currentTask = '导出完成';
    
    this.emit('progress', this.currentProgress);
    this.emit('completed', this.currentProgress);
  }
  
  errorExport(error: Error): void {
    this.currentProgress.status = 'error';
    this.currentProgress.currentTask = `导出失败: ${error.message}`;
    
    this.emit('progress', this.currentProgress);
    this.emit('error', error);
  }
}
```

## Dependencies
- 依赖任务011（Canvas图片生成）完成
- 依赖任务012（分享模板设计）完成

## Effort Estimate
- **Size**: L (大)
- **Estimated Hours**: 12-16 小时

## Definition of Done
- [ ] 图片导出管理器完整实现，支持多种导出格式
- [ ] 微信小程序相册保存功能完成，包括权限管理和错误处理
- [ ] H5平台文件下载功能实现，支持各种浏览器的下载特性
- [ ] 云存储上传集成完成，支持腾讯云存储服务
- [ ] 图片压缩和优化算法实施，显著减小文件大小
- [ ] 批量导出功能完善，支持一次生成多种规格图片
- [ ] 导出进度反馈系统实现，提供实时的进度信息
- [ ] 错误处理和重试机制完善，确保导出过程稳定可靠
- [ ] 跨平台兼容性测试通过，在不同设备和浏览器上正常工作
- [ ] 性能测试达标，导出速度满足用户体验要求
- [ ] 内存管理和资源清理完善，无内存泄漏问题
- [ ] 单元测试覆盖率达到85%以上，核心功能充分测试
- [ ] 集成测试通过，与图片生成和模板系统协同工作正常
- [ ] 代码审查完成，符合代码质量和安全最佳实践
- [ ] 使用文档和API文档编写完整，包含使用示例和最佳实践