---
name: 图片预览功能
status: open
created: 2025-09-09T09:19:22Z
updated: 2025-09-10T06:15:48Z
github: https://github.com/terry237tm/sports-record-sharing-app/issues/21
depends_on: [016, 017, 018]
parallel: true
conflicts_with: []
---

# 图片预览功能

## Description
实现运动记录中图片的预览功能，支持多图浏览、手势缩放、滑动切换等交互操作。提供全屏查看体验，支持手势操作和图片保存功能。优化图片加载性能，确保流畅的用户体验。

## Acceptance Criteria
- [ ] 图片预览组件开发，支持全屏查看模式
- [ ] 多图浏览功能，支持左右滑动切换图片
- [ ] 手势缩放功能，支持双指缩放和双击放大
- [ ] 图片滑动切换动画，流畅的过渡效果
- [ ] 图片指示器显示，显示当前图片位置和总数
- [ ] 图片加载优化，支持懒加载和预加载策略
- [ ] 手势冲突处理，避免与页面滚动冲突
- [ ] 图片保存功能，支持保存到本地相册
- [ ] 加载状态管理，包含加载动画和错误处理
- [ ] 响应式设计，适配不同屏幕尺寸和方向
- [ ] 跨平台兼容性，微信小程序和H5功能一致
- [ ] 性能优化，确保大量图片情况下的流畅体验

## Technical Details
### 图片预览组件结构
```typescript
// 图片预览器属性接口
interface ImageViewerProps {
  images: string[];
  visible: boolean;
  currentIndex?: number;
  onClose: () => void;
  onIndexChange?: (index: number) => void;
  onSave?: (imageUrl: string) => void;
  enableZoom?: boolean;
  enableSwipe?: boolean;
  showIndicator?: boolean;
}

// 图片预览器状态接口
interface ImageViewerState {
  currentIndex: number;
  scale: number;
  position: { x: number; y: number };
  isZooming: boolean;
  isDragging: boolean;
  imageLoaded: boolean[];
  imageErrors: boolean[];
  loadingProgress: number;
}

// 图片预览器组件
const ImageViewer: React.FC<ImageViewerProps> = ({
  images,
  visible,
  currentIndex = 0,
  onClose,
  onIndexChange,
  onSave,
  enableZoom = true,
  enableSwipe = true,
  showIndicator = true
}) => {
  const [state, setState] = useState<ImageViewerState>({
    currentIndex,
    scale: 1,
    position: { x: 0, y: 0 },
    isZooming: false,
    isDragging: false,
    imageLoaded: new Array(images.length).fill(false),
    imageErrors: new Array(images.length).fill(false),
    loadingProgress: 0
  });

  // 手势处理逻辑
  const handleTouchStart = (event: ITouchEvent) => {
    const touches = event.touches;
    
    if (touches.length === 1) {
      // 单指操作 - 拖拽
      handleDragStart(touches[0]);
    } else if (touches.length === 2 && enableZoom) {
      // 双指操作 - 缩放
      handleZoomStart(touches[0], touches[1]);
    }
  };

  const handleTouchMove = (event: ITouchEvent) => {
    const touches = event.touches;
    
    if (touches.length === 1 && state.isDragging) {
      handleDragMove(touches[0]);
    } else if (touches.length === 2 && state.isZooming) {
      handleZoomMove(touches[0], touches[1]);
    }
  };

  const handleTouchEnd = (event: ITouchEvent) => {
    if (state.isDragging) {
      handleDragEnd();
    } else if (state.isZooming) {
      handleZoomEnd();
    }
  };

  return (
    <View 
      className="image-viewer-overlay"
      style={{ display: visible ? 'flex' : 'none' }}
      onClick={handleOverlayClick}
    >
      {/* 图片容器 */}
      <View 
        className="image-viewer-container"
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onClick={(e) => e.stopPropagation()}
      >
        {/* 图片列表 */}
        <ScrollView
          className="image-scroll-view"
          scrollX
          scrollWithAnimation
          currentIndex={state.currentIndex}
          onScroll={handleScroll}
          enableFlex
        >
          {images.map((image, index) => (
            <View key={index} className="image-item">
              <Image
                className="viewer-image"
                src={image}
                mode="aspectFit"
                style={{
                  transform: `scale(${state.scale}) translate(${state.position.x}px, ${state.position.y}px)`,
                  transition: state.isZooming || state.isDragging ? 'none' : 'transform 0.3s ease'
                }}
                onLoad={() => handleImageLoad(index)}
                onError={() => handleImageError(index)}
                showMenuByLongpress
              />
              
              {/* 加载状态 */}
              {!state.imageLoaded[index] && !state.imageErrors[index] && (
                <View className="image-loading">
                  <ActivityIndicator size="large" />
                  <Text className="loading-text">图片加载中...</Text>
                </View>
              )}
              
              {/* 错误状态 */}
              {state.imageErrors[index] && (
                <View className="image-error">
                  <Icon type="picture-fail" size="large" />
                  <Text className="error-text">图片加载失败</Text>
                  <Button size="small" onClick={() => retryImageLoad(index)}>
                    重新加载
                  </Button>
                </View>
              )}
            </View>
          ))}
        </ScrollView>
        
        {/* 图片指示器 */}
        {showIndicator && images.length > 1 && (
          <View className="image-indicator">
            <Text className="indicator-text">
              {state.currentIndex + 1} / {images.length}
            </Text>
          </View>
        )}
        
        {/* 关闭按钮 */}
        <View className="viewer-close" onClick={onClose}>
          <Icon type="close" size="large" color="#ffffff" />
        </View>
        
        {/* 保存按钮 */}
        {onSave && (
          <View className="viewer-save" onClick={() => handleSaveImage()}>
            <Icon type="download" size="large" color="#ffffff" />
          </View>
        )}
      </View>
    </View>
  );
};
```

### 手势处理逻辑
```typescript
// 拖拽处理类
class DragHandler {
  private startPoint: { x: number; y: number } | null = null;
  private startPosition: { x: number; y: number } | null = null;
  private isDragging = false;

  start(touch: Touch, currentPosition: { x: number; y: number }): void {
    this.startPoint = { x: touch.clientX, y: touch.clientY };
    this.startPosition = { ...currentPosition };
    this.isDragging = true;
  }

  move(touch: Touch): { x: number; y: number } | null {
    if (!this.isDragging || !this.startPoint || !this.startPosition) {
      return null;
    }

    const deltaX = touch.clientX - this.startPoint.x;
    const deltaY = touch.clientY - this.startPoint.y;

    return {
      x: this.startPosition.x + deltaX,
      y: this.startPosition.y + deltaY
    };
  }

  end(): void {
    this.startPoint = null;
    this.startPosition = null;
    this.isDragging = false;
  }

  get isActive(): boolean {
    return this.isDragging;
  }
}

// 缩放处理类
class ZoomHandler {
  private startDistance = 0;
  private startScale = 1;
  private isZooming = false;
  private minScale = 0.5;
  private maxScale = 3;

  start(touch1: Touch, touch2: Touch, currentScale: number): void {
    this.startDistance = this.getDistance(touch1, touch2);
    this.startScale = currentScale;
    this.isZooming = true;
  }

  move(touch1: Touch, touch2: Touch): number | null {
    if (!this.isZooming) {
      return null;
    }

    const currentDistance = this.getDistance(touch1, touch2);
    const scaleRatio = currentDistance / this.startDistance;
    const newScale = this.startScale * scaleRatio;

    return Math.max(this.minScale, Math.min(this.maxScale, newScale));
  }

  end(): void {
    this.startDistance = 0;
    this.startScale = 1;
    this.isZooming = false;
  }

  private getDistance(touch1: Touch, touch2: Touch): number {
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  get isActive(): boolean {
    return this.isZooming;
  }
}
```

### 图片加载优化
```typescript
// 图片预加载管理器
class ImagePreloader {
  private cache = new Map<string, HTMLImageElement>();
  private loadingQueue: string[] = [];
  private maxConcurrent = 3;
  private currentLoading = 0;

  async preloadImages(urls: string[]): Promise<void> {
    // 添加当前图片和前后各2张到预加载队列
    const preloadUrls = this.getPreloadUrls(urls);
    
    for (const url of preloadUrls) {
      if (!this.cache.has(url)) {
        this.loadingQueue.push(url);
      }
    }

    this.processQueue();
  }

  private async processQueue(): Promise<void> {
    while (this.loadingQueue.length > 0 && this.currentLoading < this.maxConcurrent) {
      const url = this.loadingQueue.shift()!;
      this.currentLoading++;

      try {
        await this.loadImage(url);
      } finally {
        this.currentLoading--;
      }
    }
  }

  private async loadImage(url: string): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => {
        this.cache.set(url, img);
        resolve(img);
      };
      
      img.onerror = () => {
        reject(new Error(`Failed to load image: ${url}`));
      };
      
      img.src = url;
    });
  }

  private getPreloadUrls(allUrls: string[]): string[] {
    const currentIndex = this.getCurrentIndex();
    const preloadUrls: string[] = [];
    
    // 当前图片
    if (allUrls[currentIndex]) {
      preloadUrls.push(allUrls[currentIndex]);
    }
    
    // 前后各2张
    for (let i = 1; i <= 2; i++) {
      if (allUrls[currentIndex - i]) {
        preloadUrls.push(allUrls[currentIndex - i]);
      }
      if (allUrls[currentIndex + i]) {
        preloadUrls.push(allUrls[currentIndex + i]);
      }
    }
    
    return preloadUrls;
  }

  private getCurrentIndex(): number {
    // 从状态管理或组件状态获取当前索引
    return 0;
  }

  getCachedImage(url: string): HTMLImageElement | undefined {
    return this.cache.get(url);
  }

  clearCache(): void {
    this.cache.clear();
  }
}
```

### 图片保存功能
```typescript
// 图片保存管理器
class ImageSaveManager {
  private isWeChat = process.env.TARO_ENV === 'weapp';

  async saveImage(imageUrl: string): Promise<SaveResult> {
    try {
      if (this.isWeChat) {
        return await this.saveToWeChatAlbum(imageUrl);
      } else {
        return await this.saveToWebAlbum(imageUrl);
      }
    } catch (error) {
      return {
        success: false,
        error: error.message || '保存失败'
      };
    }
  }

  private async saveToWeChatAlbum(imageUrl: string): Promise<SaveResult> {
    // 微信小程序保存图片
    return new Promise((resolve) => {
      Taro.saveImageToPhotosAlbum({
        filePath: imageUrl,
        success: () => {
          resolve({ success: true });
        },
        fail: (error) => {
          resolve({ 
            success: false, 
            error: error.errMsg || '保存失败'
          });
        }
      });
    });
  }

  private async saveToWebAlbum(imageUrl: string): Promise<SaveResult> {
    // H5保存图片
    try {
      const response = await fetch(imageUrl);
      const blob = await response.blob();
      
      // 创建下载链接
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `sport_record_${Date.now()}.jpg`;
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      window.URL.revokeObjectURL(url);
      
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: '浏览器保存失败'
      };
    }
  }
}

interface SaveResult {
  success: boolean;
  error?: string;
}
```

## Dependencies
- 依赖任务016（记录列表展示）提供图片数据展示基础
- 依赖任务017（分页加载优化）提供图片加载性能优化支持
- 依赖任务018（详情页面开发）提供详情页图片展示集成

## Effort Estimate
- **Size**: M (中)
- **Estimated Hours**: 8-12 小时

## Definition of Done
- [ ] 图片预览组件完整实现，支持全屏查看模式
- [ ] 多图浏览功能完成，支持左右滑动切换
- [ ] 手势缩放功能实现，支持双指和双击缩放
- [ ] 图片切换动画完成，过渡效果流畅自然
- [ ] 图片指示器显示正确，位置和总数信息准确
- [ ] 图片加载优化完成，懒加载和预加载策略有效
- [ ] 手势冲突处理完善，避免与页面滚动冲突
- [ ] 图片保存功能实现，支持保存到本地相册
- [ ] 加载状态管理完成，包含加载动画和错误处理
- [ ] 响应式设计适配完成，不同屏幕尺寸表现良好
- [ ] 跨平台兼容性测试通过，微信小程序和H5功能一致
- [ ] 性能优化完成，大量图片情况下保持流畅体验
- [ ] 单元测试覆盖率达到80%以上，核心功能充分测试
- [ ] 用户体验优化完成，交互流畅，反馈及时
- [ ] 代码审查通过，符合项目编码规范和最佳实践
- [ ] 文档编写完成，包含使用说明和API文档

## Performance Requirements
- 图片切换响应时间：< 200ms
- 缩放操作响应时间：< 100ms
- 图片加载时间：< 1秒（单张图片）
- 预加载命中率：> 90%
- 内存占用控制：< 100MB（20张图片）

## Security and Privacy
- 图片访问权限控制，防止未授权访问
- 图片保存权限验证，确保用户授权
- 图片内容安全检查，防止恶意图片
- 用户隐私保护，不泄露图片元数据

## Monitoring and Maintenance
- 图片加载成功率监控
- 手势操作错误率统计
- 性能指标收集和分析
- 用户行为路径追踪
- 异常错误日志收集

## Future Enhancements
- 图片编辑功能
- 滤镜和特效支持
- 批量操作功能
- 云端同步备份
- AI图片识别
- 社交分享优化

## Analytics Best Practices
- 建立图片预览使用指标体系
- 分析用户浏览行为模式
- 监控功能使用频率
- 优化交互体验设计
- 持续改进用户满意度

## Compliance and Governance
- 图片内容合规性检查
- 版权保护机制
- 用户隐私保护验证
- 数据安全审计
- 建立内容治理流程

## Documentation and Training
- 编写图片预览功能手册
- 提供手势操作指南
- 制作功能演示视频
- 建立最佳实践库
- 开展用户培训和支持

## Performance Optimization
- 图片压缩和格式优化
- CDN加速和缓存策略
- 内存管理和垃圾回收
- 手势识别算法优化
- 渲染性能提升

## Accessibility
- 支持屏幕阅读器图片描述
- 键盘导航支持
- 高对比度模式适配
- 字体大小调节
- 色盲友好设计

## Internationalization
- 多语言提示信息
- 本地化图片格式
- 时区适配
- 地区化功能
- 文化习惯考虑

## Testing Strategy
- 功能测试覆盖所有手势
- 兼容性测试多平台
- 性能测试压力测试
- 安全测试漏洞扫描
- 用户体验测试验证

## Deployment Considerations
- 版本兼容性处理
- 功能开关控制
- 灰度发布方案
- 回滚机制准备
- 监控告警配置

## Risk Assessment
- 手势识别准确性风险
- 图片加载性能风险
- 内存泄漏风险
- 兼容性问题风险
- 用户体验风险

## Success Metrics
- 功能使用率
- 用户满意度
- 性能指标达成率
- 错误率控制
- 用户留存提升

## Maintenance Plan
- 定期功能更新
- 性能持续优化
- 安全漏洞修复
- 用户反馈处理
- 数据分析改进

## Technical Debt Management
- 代码重构计划
- 依赖更新策略
- 性能优化迭代
- 架构演进规划
- 技术栈升级路径

## Knowledge Transfer
- 技术文档整理
- 代码注释完善
- 架构设计说明
- 最佳实践总结
- 问题解决方案

## Continuous Improvement
- 用户反馈收集
- 数据分析驱动
- A/B测试验证
- 迭代优化计划
- 创新功能探索

## Team Collaboration
- 开发流程规范
- 代码审查标准
- 测试质量保证
- 发布管理流程
- 运维支持机制

## Stakeholder Communication
- 项目进度汇报
- 风险问题沟通
- 成果展示演示
- 用户培训支持
- 商业价值体现

## Quality Assurance
- 代码质量检查
- 功能完整性验证
- 性能基准测试
- 安全漏洞扫描
- 用户体验评估

## Innovation Opportunities
- AI图像识别集成
- AR增强现实支持
- 智能推荐算法
- 社交功能扩展
- 商业模式创新

## Scalability Considerations
- 架构扩展性设计
- 图片数量增长应对
- 用户规模扩展
- 功能模块扩展
- 性能横向扩展

## Business Value
- 用户体验提升
- 功能价值体现
- 数据资产积累
- 品牌影响力增强
- 商业变现支持

## Competitive Analysis
- 竞品功能对比
- 用户体验优势
- 技术创新亮点
- 市场定位分析
- 差异化竞争策略

## Roadmap Alignment
- 产品战略规划
- 技术发展路线
- 市场需求匹配
- 资源配置优化
- 里程碑达成

## Resource Requirements
- 开发人力投入
- 设计资源支持
- 测试环境配置
- 运维服务保障
- 预算成本控制

## Timeline Management
- 开发周期规划
- 里程碑设置
- 风险缓冲预留
- 质量保证时间
- 发布窗口安排

## Communication Plan
- 团队内部沟通
- 跨部门协作
- 上级汇报机制
- 用户反馈渠道
- 外部合作沟通

## Risk Mitigation
- 技术风险预案
- 进度风险应对
- 质量风险控制
- 资源风险保障
- 外部风险缓冲

## Success Factors
- 技术实现质量
- 用户体验满意度
- 功能完整性
- 性能稳定性
- 商业价值实现

## Lessons Learned
- 开发经验总结
- 技术难点攻克
- 团队协作优化
- 流程改进建议
- 知识积累沉淀

## Future Considerations
- 技术发展趋势
- 市场需求变化
- 用户行为演进
- 竞争环境分析
- 战略规划调整

## Conclusion
图片预览功能是运动记录详情展示的重要组成部分，需要综合考虑用户体验、性能优化、手势交互等多个方面。通过精心设计和实现，为用户提供流畅、直观的图片浏览体验，同时为后续的功能扩展和商业化运营奠定坚实基础。
