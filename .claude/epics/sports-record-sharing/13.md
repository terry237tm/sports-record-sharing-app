---
name: Canvas图片生成
status: open
created: 2025-09-09T09:19:22Z
updated: 2025-09-10T06:15:48Z
github: https://github.com/terry237tm/sports-record-sharing-app/issues/13
depends_on: [001, 002, 003, 004, 005]
parallel: true
conflicts_with: []
---

# Canvas图片生成

## Description
实现基于Canvas的运动记录分享图片生成功能，通过离屏Canvas技术生成高质量的分享图片。支持动态布局、图片合成、文字渲染等功能，确保生成的分享图片美观且具有个性化特色。

## Acceptance Criteria
- [ ] Canvas图片生成管理器类实现完成，支持链式调用
- [ ] 离屏Canvas初始化配置，支持多种尺寸和分辨率
- [ ] 背景图片绘制功能，支持渐变、纹理、图片背景
- [ ] 用户信息绘制模块，包含头像、昵称、运动日期
- [ ] 运动数据可视化组件，支持数值、图表、图标展示
- [ ] 运动图片合成处理，支持多张图片布局和滤镜效果
- [ ] 文字渲染引擎，支持多种字体、颜色、对齐方式
- [ ] 图片导出功能，支持不同格式和质量参数
- [ ] 性能优化实现，包含图片预加载、缓存机制
- [ ] 错误处理和降级方案，确保生成过程的稳定性

## Technical Details
### Canvas绘制架构
```typescript
// 分享图片生成器类
class ShareImageGenerator {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private config: ShareImageConfig;
  
  constructor(config: ShareImageConfig) {
    this.config = config;
    this.setupCanvas();
  }
  
  async generate(data: ShareImageData): Promise<string> {
    // 初始化绘制环境
    this.setupCanvas();
    
    // 绘制背景
    await this.drawBackground();
    
    // 绘制用户信息
    this.drawUserInfo(data.userInfo);
    
    // 绘制运动数据
    this.drawSportData(data.sportRecord);
    
    // 绘制运动图片
    await this.drawImages(data.images);
    
    // 绘制装饰元素
    this.drawDecorations();
    
    // 导出图片
    return this.exportImage();
  }
}
```

### 离屏Canvas优化
```typescript
// 离屏Canvas管理器
class OffscreenCanvasManager {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  
  createOffscreenCanvas(width: number, height: number): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.width = width * 2; // 2倍像素密度
    canvas.height = height * 2;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.scale(2, 2); // 缩放比例
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    
    return canvas;
  }
  
  // 图片预加载和缓存
  private imageCache = new Map<string, HTMLImageElement>();
  
  async preloadImage(url: string): Promise<HTMLImageElement> {
    if (this.imageCache.has(url)) {
      return this.imageCache.get(url)!;
    }
    
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        this.imageCache.set(url, img);
        resolve(img);
      };
      img.onerror = reject;
      img.src = url;
    });
  }
}
```

### 动态布局计算
```typescript
// 布局计算引擎
class LayoutEngine {
  private container: { width: number; height: number };
  
  calculateLayout(elements: LayoutElement[]): LayoutResult {
    const result: LayoutResult = {
      positions: [],
      totalHeight: 0
    };
    
    let currentY = this.config.padding;
    
    for (const element of elements) {
      const position = this.calculateElementPosition(element, currentY);
      result.positions.push(position);
      currentY = position.y + position.height + this.config.spacing;
    }
    
    result.totalHeight = currentY - this.config.spacing + this.config.padding;
    return result;
  }
  
  private calculateElementPosition(element: LayoutElement, startY: number): ElementPosition {
    // 根据元素类型计算位置和尺寸
    switch (element.type) {
      case 'user-info':
        return this.calculateUserInfoPosition(element, startY);
      case 'sport-data':
        return this.calculateSportDataPosition(element, startY);
      case 'images':
        return this.calculateImagesPosition(element, startY);
      case 'text':
        return this.calculateTextPosition(element, startY);
      default:
        return { x: 0, y: startY, width: 0, height: 0 };
    }
  }
}
```

### 图片合成处理
```typescript
// 图片合成处理器
class ImageCompositor {
  async compositeImages(
    ctx: CanvasRenderingContext2D,
    images: string[],
    layout: ImageLayout
  ): Promise<void> {
    const imageElements = await Promise.all(
      images.map(url => this.loadAndProcessImage(url))
    );
    
    // 根据布局绘制图片
    for (let i = 0; i < imageElements.length; i++) {
      const img = imageElements[i];
      const position = layout.positions[i];
      
      if (layout.style === 'rounded') {
        this.drawRoundedImage(ctx, img, position);
      } else if (layout.style === 'shadow') {
        this.drawImageWithShadow(ctx, img, position);
      } else {
        ctx.drawImage(img, position.x, position.y, position.width, position.height);
      }
    }
  }
  
  private drawRoundedImage(
    ctx: CanvasRenderingContext2D,
    img: HTMLImageElement,
    position: ImagePosition
  ): void {
    const { x, y, width, height, radius = 8 } = position;
    
    // 创建圆角路径
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + width, y, x + width, y + height, radius);
    ctx.arcTo(x + width, y + height, x, y + height, radius);
    ctx.arcTo(x, y + height, x, y, radius);
    ctx.arcTo(x, y, x + width, y, radius);
    ctx.closePath();
    
    // 裁剪并绘制图片
    ctx.save();
    ctx.clip();
    ctx.drawImage(img, x, y, width, height);
    ctx.restore();
  }
}
```

### 性能优化策略
- **图片预加载**: 提前加载所有需要的图片资源
- **离屏渲染**: 使用离屏Canvas避免页面重绘
- **缓存机制**: 缓存生成的图片和中间结果
- **分步绘制**: 复杂绘制操作分步骤执行，避免阻塞
- **Web Worker**: 图片处理任务可以考虑使用Web Worker

### 错误处理和降级
```typescript
// 错误处理管理器
class ErrorHandler {
  async handleGenerationError(error: Error, fallbackData: any): Promise<string> {
    console.error('图片生成失败:', error);
    
    // 降级方案：使用预设模板
    if (error instanceof ImageLoadError) {
      return this.generateWithFallbackTemplate(fallbackData);
    }
    
    if (error instanceof CanvasRenderingError) {
      return this.generateSimpleImage(fallbackData);
    }
    
    // 最终降级：返回默认图片
    return this.getDefaultShareImage();
  }
  
  private generateSimpleImage(data: any): string {
    // 生成简单的文字图片作为降级方案
    const canvas = document.createElement('canvas');
    canvas.width = 400;
    canvas.height = 300;
    
    const ctx = canvas.getContext('2d')!;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#333333';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('运动记录分享', canvas.width / 2, canvas.height / 2);
    
    return canvas.toDataURL('image/png', 0.8);
  }
}
```

## Dependencies
- 依赖任务001-005（基础架构和类型定义）
- 依赖任务006-010（核心功能实现）

## Effort Estimate
- **Size**: XL (超大)
- **Estimated Hours**: 18-22 小时

## Definition of Done
- [ ] Canvas图片生成核心功能完整实现，支持多种布局和样式
- [ ] 离屏Canvas优化完成，生成性能达到要求（<2秒）
- [ ] 动态布局计算引擎正确实现，自适应不同内容
- [ ] 图片合成和特效处理功能完善，支持圆角、阴影等效果
- [ ] 文字渲染引擎支持多种字体和样式，渲染效果清晰
- [ ] 性能优化措施实施完成，内存使用合理，无内存泄漏
- [ ] 错误处理和降级方案完善，异常情况有合适的处理策略
- [ ] 单元测试覆盖率达到85%以上，核心逻辑充分测试
- [ ] 集成测试通过，与现有功能模块协同工作正常
- [ ] 性能测试达标，图片生成速度满足用户体验要求
- [ ] 代码审查完成，符合代码质量和安全最佳实践
- [ ] 文档和使用说明编写完整，包含API文档和示例代码
