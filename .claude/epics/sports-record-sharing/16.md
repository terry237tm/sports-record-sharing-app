---
name: 微信分享集成
status: open
created: 2025-09-09T09:19:22Z
updated: 2025-09-10T06:15:48Z
github: https://github.com/terry237tm/sports-record-sharing-app/issues/16
depends_on: [011, 012, 013]
parallel: true
conflicts_with: []
---

# 微信分享集成

## Description
集成微信分享功能，实现分享到朋友圈、微信好友、微信群等场景。包括分享内容配置、分享图片生成、分享状态监听、分享统计分析等功能，提供完整的微信分享解决方案。

## Acceptance Criteria
- [ ] 微信分享API集成完成，支持onShareAppMessage和onShareTimeline
- [ ] 分享内容动态配置，支持自定义标题、描述、图片等内容
- [ ] 分享图片实时生成，根据当前记录生成对应的分享图片
- [ ] 分享到朋友圈功能，支持分享记录到用户朋友圈
- [ ] 分享给好友功能，支持分享给微信好友和微信群
- [ ] 分享状态监听，获取分享成功、取消、失败等状态
- [ ] 分享参数追踪，记录分享来源和渠道信息
- [ ] 分享预览功能，在分享前预览分享内容效果
- [ ] 分享历史记录，记录用户的分享行为和统计
- [ ] 分享内容审核，确保分享内容符合微信规范

## Technical Details
### 微信分享管理器
```typescript
// 微信分享管理器
class WeChatShareManager {
  private shareConfig: ShareConfig;
  private imageGenerator: ShareImageGenerator;
  private analytics: ShareAnalytics;
  
  constructor(config: ShareConfig) {
    this.shareConfig = config;
    this.imageGenerator = new ShareImageGenerator();
    this.analytics = new ShareAnalytics();
  }
  
  // 分享到好友
  async shareToFriend(record: SportRecord): Promise<ShareResult> {
    try {
      // 生成分享图片
      const shareImage = await this.generateShareImage(record);
      
      // 构建分享内容
      const shareContent = this.buildShareContent(record, 'friend');
      
      // 记录分享行为
      await this.analytics.trackShare('friend', record._id);
      
      return {
        title: shareContent.title,
        path: shareContent.path,
        imageUrl: shareImage,
        success: () => {
          this.handleShareSuccess('friend', record._id);
        },
        fail: (error) => {
          this.handleShareError('friend', record._id, error);
        }
      };
      
    } catch (error) {
      throw new ShareError(`好友分享失败: ${error.message}`);
    }
  }
  
  // 分享到朋友圈
  async shareToTimeline(record: SportRecord): Promise<ShareResult> {
    try {
      // 朋友圈分享需要特殊处理
      const shareImage = await this.generateTimelineImage(record);
      const shareContent = this.buildShareContent(record, 'timeline');
      
      await this.analytics.trackShare('timeline', record._id);
      
      return {
        title: shareContent.title,
        query: shareContent.query,
        imageUrl: shareImage,
        success: () => {
          this.handleShareSuccess('timeline', record._id);
        }
      };
      
    } catch (error) {
      throw new ShareError(`朋友圈分享失败: ${error.message}`);
    }
  }
  
  // 生成分享图片
  private async generateShareImage(record: SportRecord): Promise<string> {
    try {
      // 使用缓存避免重复生成
      const cacheKey = `share_image_${record._id}`;
      const cachedImage = await this.getCachedImage(cacheKey);
      
      if (cachedImage) {
        return cachedImage;
      }
      
      // 生成新的分享图片
      const imageData = await this.imageGenerator.generate({
        template: this.shareConfig.template,
        data: {
          userInfo: await this.getUserInfo(),
          sportRecord: record,
          images: record.images
        }
      });
      
      // 上传到云存储获取URL
      const uploadResult = await this.uploadShareImage(imageData);
      
      // 缓存结果
      await this.cacheImage(cacheKey, uploadResult.fileUrl);
      
      return uploadResult.fileUrl;
      
    } catch (error) {
      // 使用默认分享图片
      return this.shareConfig.defaultImageUrl;
    }
  }
  
  // 构建分享内容
  private buildShareContent(record: SportRecord, type: 'friend' | 'timeline'): ShareContent {
    const sportTypeName = this.getSportTypeName(record.sportType);
    
    if (type === 'friend') {
      return {
        title: `我刚完成了${record.data.duration}分钟的${sportTypeName}，消耗了${record.data.calories}卡路里！`,
        path: `/pages/record/detail?id=${record._id}`,
        desc: record.description || '快来查看我的运动记录吧！',
        imageUrl: ''
      };
    } else {
      // 朋友圈分享
      return {
        title: `${sportTypeName}记录 - ${record.data.duration}分钟 | ${record.data.calories}卡路里`,
        query: `id=${record._id}&source=timeline`,
        imageUrl: ''
      };
    }
  }
}
```

### 分享页面集成
```typescript
// 分享页面混入
const ShareMixin = {
  // 分享给好友
  onShareAppMessage(res: any) {
    if (res.from === 'button') {
      // 来自页面内分享按钮
      const record = this.getCurrentRecord();
      return this.shareManager.shareToFriend(record);
    }
    
    // 默认分享
    return {
      title: '运动记录分享',
      path: '/pages/index/index',
      imageUrl: '/assets/images/default-share.png'
    };
  },
  
  // 分享到朋友圈（微信小程序）
  onShareTimeline() {
    const record = this.getCurrentRecord();
    if (record) {
      return this.shareManager.shareToTimeline(record);
    }
    
    return {
      title: '我的运动记录',
      query: 'source=timeline',
      imageUrl: '/assets/images/default-timeline.png'
    };
  },
  
  // 分享到朋友圈（H5）
  async shareToTimelineH5() {
    if (!this.isWeChat()) {
      Taro.showToast({
        title: '请在微信中打开',
        icon: 'none'
      });
      return;
    }
    
    try {
      const record = this.getCurrentRecord();
      const shareResult = await this.shareManager.shareToTimeline(record);
      
      // 调用微信JS-SDK
      await this.callWeChatJSAPI('updateTimelineShareData', {
        title: shareResult.title,
        link: window.location.href.split('#')[0] + '#' + shareResult.path,
        imgUrl: shareResult.imageUrl,
        success: () => {
          Taro.showToast({
            title: '分享准备完成',
            icon: 'success'
          });
        }
      });
      
    } catch (error) {
      Taro.showToast({
        title: '分享准备失败',
        icon: 'none'
      });
    }
  }
};
```

### 分享内容审核
```typescript
// 分享内容审核器
class ShareContentAuditor {
  private sensitiveWords: string[] = [
    '广告', '推广', '营销', '代购', '兼职',
    '赌博', '彩票', '投资', '理财', '赚钱',
    '政治', '暴力', '色情', '违法', '犯罪'
  ];
  
  // 内容安全检测
  async auditContent(content: ShareContent): Promise<AuditResult> {
    try {
      // 敏感词检测
      const wordCheck = this.checkSensitiveWords(content.title + content.desc);
      if (wordCheck.hasSensitive) {
        return {
          passed: false,
          reason: '包含敏感词汇',
          violations: wordCheck.words
        };
      }
      
      // 调用微信内容安全API
      const wxCheck = await this.callWeChatSecurityAPI(content);
      if (!wxCheck.safe) {
        return {
          passed: false,
          reason: '违反内容安全规范',
          violations: wxCheck.violations
        };
      }
      
      // 图片内容检测
      if (content.imageUrl) {
        const imageCheck = await this.checkImageContent(content.imageUrl);
        if (!imageCheck.safe) {
          return {
            passed: false,
            reason: '图片内容违规',
            violations: imageCheck.violations
          };
        }
      }
      
      return {
        passed: true,
        reason: '',
        violations: []
      };
      
    } catch (error) {
      // 审核失败时，默认不通过
      return {
        passed: false,
        reason: '审核服务异常',
        violations: ['系统审核失败']
      };
    }
  }
  
  private checkSensitiveWords(text: string): SensitiveWordCheck {
    const foundWords: string[] = [];
    
    for (const word of this.sensitiveWords) {
      if (text.includes(word)) {
        foundWords.push(word);
      }
    }
    
    return {
      hasSensitive: foundWords.length > 0,
      words: foundWords
    };
  }
  
  private async callWeChatSecurityAPI(content: ShareContent): Promise<WeChatSecurityResult> {
    try {
      // 调用微信内容安全API
      const result = await cloud.callFunction({
        name: 'contentSecurity',
        data: {
          type: 'text',
          content: content.title + content.desc
        }
      });
      
      return {
        safe: result.result.safe,
        violations: result.result.violations || []
      };
      
    } catch (error) {
      console.error('微信内容安全检测失败:', error);
      // 出现异常时，保守策略：认为不安全
      return {
        safe: false,
        violations: ['检测服务异常']
      };
    }
  }
  
  private async checkImageContent(imageUrl: string): Promise<ImageSecurityResult> {
    try {
      // 调用图片内容安全检测
      const result = await cloud.callFunction({
        name: 'imageSecurity',
        data: {
          imageUrl: imageUrl
        }
      });
      
      return {
        safe: result.result.safe,
        violations: result.result.violations || []
      };
      
    } catch (error) {
      console.error('图片内容检测失败:', error);
      return {
        safe: false,
        violations: ['图片检测失败']
      };
    }
  }
  
  // 内容修正建议
  getContentSuggestion(content: ShareContent, auditResult: AuditResult): ContentSuggestion {
    if (auditResult.passed) {
      return { needsModification: false, suggestions: [] };
    }
    
    const suggestions: string[] = [];
    
    // 根据违规类型提供建议
    if (auditResult.reason.includes('敏感词汇')) {
      suggestions.push('请检查并替换标题和描述中的敏感词汇');
      suggestions.push('使用更加中性、积极的表达方式');
    }
    
    if (auditResult.reason.includes('图片')) {
      suggestions.push('请更换分享图片，避免使用可能违规的图片内容');
      suggestions.push('使用应用生成的默认分享图片');
    }
    
    if (auditResult.reason.includes('安全规范')) {
      suggestions.push('内容可能违反微信社区规范');
      suggestions.push('请简化分享内容，避免推广营销信息');
    }
    
    return {
      needsModification: true,
      suggestions,
      alternativeContent: this.generateAlternativeContent(content, auditResult)
    };
  }
  
  private generateAlternativeContent(
    originalContent: ShareContent,
    auditResult: AuditResult
  ): ShareContent {
    // 生成符合规范的替代内容
    return {
      ...originalContent,
      title: this.cleanSensitiveContent(originalContent.title),
      desc: this.cleanSensitiveContent(originalContent.desc || ''),
      imageUrl: originalContent.imageUrl // 图片审核失败时会使用默认图片
    };
  }
  
  private cleanSensitiveContent(text: string): string {
    let cleanedText = text;
    
    // 简单的敏感词替换
    for (const word of this.sensitiveWords) {
      const regex = new RegExp(word, 'gi');
      cleanedText = cleanedText.replace(regex, '*'.repeat(word.length));
    }
    
    return cleanedText;
  }
}
```

### 分享统计分析
```typescript
// 分享统计分析器
class ShareAnalytics {
  // 跟踪分享行为
  async trackShare(
    channel: 'friend' | 'timeline' | 'qq' | 'weibo',
    recordId: string,
    userId: string
  ): Promise<void> {
    try {
      const shareData: ShareEvent = {
        channel,
        recordId,
        userId,
        timestamp: new Date(),
        platform: this.getPlatform(),
        version: this.getAppVersion()
      };
      
      // 保存分享记录
      await this.saveShareEvent(shareData);
      
      // 更新记录分享数
      await this.incrementShareCount(recordId);
      
      // 更新用户分享统计
      await this.updateUserShareStats(userId);
      
    } catch (error) {
      console.error('分享跟踪失败:', error);
    }
  }
  
  // 获取分享统计
  async getShareStats(options: StatsOptions): Promise<ShareStats> {
    try {
      const { userId, recordId, startDate, endDate } = options;
      
      const db = cloud.database();
      let query = db.collection('share_events');
      
      // 构建查询条件
      const conditions: any = {};
      
      if (userId) {
        conditions.userId = userId;
      }
      
      if (recordId) {
        conditions.recordId = recordId;
      }
      
      if (startDate || endDate) {
        conditions.timestamp = {};
        if (startDate) {
          conditions.timestamp.$gte = startDate;
        }
        if (endDate) {
          conditions.timestamp.$lte = endDate;
        }
      }
      
      // 聚合统计
      const aggregation = await query
        .where(conditions)
        .aggregate()
        .group({
          _id: '$channel',
          count: $.sum(1),
          users: $.addToSet('$userId')
        })
        .end();
      
      const channelStats = aggregation.list.map(item => ({
        channel: item._id,
        count: item.count,
        uniqueUsers: item.users.length
      }));
      
      return {
        total: channelStats.reduce((sum, item) => sum + item.count, 0),
        channels: channelStats,
        period: {
          start: startDate,
          end: endDate
        }
      };
      
    } catch (error) {
      throw new AnalyticsError(`获取分享统计失败: ${error.message}`);
    }
  }
  
  // 分享效果分析
  async analyzeShareEffectiveness(recordId: string): Promise<ShareEffectiveness> {
    try {
      // 获取分享数据
      const shareStats = await this.getShareStats({ recordId });
      
      // 获取记录互动数据
      const recordStats = await this.getRecordStats(recordId);
      
      // 计算效果指标
      const effectiveness: ShareEffectiveness = {
        shareCount: shareStats.total,
        viewCount: recordStats.views,
        likeCount: recordStats.likes,
        commentCount: recordStats.comments,
        conversionRate: recordStats.views / Math.max(1, shareStats.total),
        engagementRate: (recordStats.likes + recordStats.comments) / Math.max(1, recordStats.views),
        viralCoefficient: shareStats.total / Math.max(1, recordStats.views),
        topChannels: shareStats.channels.sort((a, b) => b.count - a.count).slice(0, 3)
      };
      
      return effectiveness;
      
    } catch (error) {
      throw new AnalyticsError(`分享效果分析失败: ${error.message}`);
    }
  }
}
```

### 分享状态管理
```typescript
// 分享状态管理器
class ShareStateManager {
  private shareStates = new Map<string, ShareState>();
  
  // 开始分享
  startShare(shareId: string, params: ShareParams): void {
    const state: ShareState = {
      id: shareId,
      status: 'preparing',
      params,
      startTime: Date.now(),
      progress: 0
    };
    
    this.shareStates.set(shareId, state);
    this.notifyStateChange(shareId, state);
  }
  
  // 更新分享状态
  updateShareState(shareId: string, update: Partial<ShareState>): void {
    const currentState = this.shareStates.get(shareId);
    if (!currentState) {
      return;
    }
    
    const newState = { ...currentState, ...update };
    this.shareStates.set(shareId, newState);
    this.notifyStateChange(shareId, newState);
  }
  
  // 完成分享
  completeShare(shareId: string, result: ShareResult): void {
    const state = this.shareStates.get(shareId);
    if (!state) {
      return;
    }
    
    const completedState: ShareState = {
      ...state,
      status: 'completed',
      endTime: Date.now(),
      result,
      progress: 100
    };
    
    this.shareStates.set(shareId, completedState);
    this.notifyStateChange(shareId, completedState);
    
    // 延迟清理状态
    setTimeout(() => {
      this.shareStates.delete(shareId);
    }, 5000);
  }
  
  // 分享失败
  failShare(shareId: string, error: Error): void {
    const state = this.shareStates.get(shareId);
    if (!state) {
      return;
    }
    
    const failedState: ShareState = {
      ...state,
      status: 'failed',
      endTime: Date.now(),
      error: error.message,
      progress: 0
    };
    
    this.shareStates.set(shareId, failedState);
    this.notifyStateChange(shareId, failedState);
    
    // 延迟清理状态
    setTimeout(() => {
      this.shareStates.delete(shareId);
    }, 10000);
  }
  
  private notifyStateChange(shareId: string, state: ShareState): void {
    // 触发状态变更事件
    Taro.eventCenter.trigger(`share_state_change_${shareId}`, state);
  }
}
```

## Dependencies
- 依赖任务011（Canvas图片生成）完成
- 依赖任务012（分享模板设计）完成
- 依赖任务013（图片导出与保存）完成

## Effort Estimate
- **Size**: XL (超大)
- **Estimated Hours**: 16-20 小时

## Definition of Done
- [ ] 微信分享API完整集成，支持所有分享场景
- [ ] 分享内容动态配置系统完成，支持灵活的内容定制
- [ ] 分享图片实时生成功能实现，根据记录动态生成图片
- [ ] 分享到朋友圈功能完成，包括微信小程序和H5平台适配
- [ ] 分享给好友功能完善，支持好友和微信群分享
- [ ] 分享状态监听机制实现，准确获取分享结果
- [ ] 分享参数追踪功能完成，记录分享来源信息
- [ ] 分享预览功能实现，提供分享前预览能力
- [ ] 分享内容审核系统集成，确保内容符合规范
- [ ] 分享统计分析功能完成，提供详细的分享数据统计
- [ ] 分享历史记录管理实现，追踪用户分享行为
- [ ] 跨平台兼容性测试通过，在不同平台表现一致
- [ ] 错误处理和用户体验优化完善，提供友好的错误提示
- [ ] 单元测试覆盖率达到85%以上，核心功能充分测试
- [ ] 性能测试达标，分享功能响应迅速
- [ ] 代码审查完成，符合微信开发规范和安全最佳实践
- [ ] 分享功能文档和使用指南编写完整，包含集成说明和最佳实践
- [ ] A/B测试框架集成，支持分享效果优化测试
- [ ] 分享功能监控和告警配置完成，及时发现和解决问题
- [ ] 用户隐私保护合规，符合相关法规要求
- [ ] 分享功能灰度发布方案制定，支持渐进式发布和回滚策略

## Platform-Specific Notes
### 微信小程序
- 需要配置合法的分享域名
- 分享图片大小不能超过20KB（建议使用网络图片）
- 分享路径必须在app.json中声明
- 需要处理用户拒绝分享的情况

### H5平台
- 需要使用微信JS-SDK进行分享配置
- 需要后端配合生成签名
- 分享功能需要在微信环境中使用
- 需要考虑浏览器兼容性

### 分享优化建议
- 分享标题要简洁有力，突出运动成就
- 分享图片要美观清晰，体现个人特色
- 分享路径要携带统计参数，便于分析
- 分享内容要定期更新，保持新鲜感
- 分享功能要有完善的错误处理和降级方案

## Security Considerations
- 分享内容需要进行安全审核
- 分享链接需要防止被恶意利用
- 用户隐私信息需要妥善处理
- 分享统计需要遵守相关法规
- 需要防范分享功能的滥用行为

## Performance Optimization
- 分享图片需要预生成和缓存
- 分享内容需要异步加载
- 分享状态需要实时更新
- 分享统计需要批量处理
- 需要控制分享频率防止滥用

## Legal Compliance
- 需要遵守微信分享规范
- 需要保护用户隐私信息
- 需要符合内容审核要求
- 需要遵守平台运营规范
- 需要建立投诉处理机制

## Monitoring and Analytics
- 需要监控分享成功率
- 需要分析分享渠道效果
- 需要追踪分享转化路径
- 需要统计分享用户行为
- 需要建立异常告警机制

## Future Enhancements
- 支持分享到更多平台（QQ、微博等）
- 支持生成分享二维码
- 支持分享内容个性化推荐
- 支持分享效果智能分析
- 支持分享内容自动生成摘要
- 支持分享图片智能美化
- 支持分享内容多语言支持
- 支持分享数据实时同步
- 支持分享内容版本管理
- 支持分享模板动态更新
